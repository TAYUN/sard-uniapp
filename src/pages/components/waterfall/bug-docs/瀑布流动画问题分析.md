# 瀑布流动画问题分析

## 问题描述

在瀑布流组件的重排过程中，发现一个动画问题：

- **注释掉** `item.visible = false` 代码时，切换列数有平滑动画效果
- **启用** `item.visible = false` 代码时，切换列数没有动画效果

相关代码：

```typescript
// 如果是完整重排，先隐藏所有待处理的项目
// if (pendingItems.length > 0) {
//   pendingItems.forEach((item) => {
//     item.visible = false
//   })
// }
```

## 问题分析

### 动画原理

瀑布流的动画效果依赖于 CSS `transform` 属性的过渡：

```scss
transition: transform var(--sar-waterfall-duration) ease-out;
```

动画需要有**明确的起始位置**和**结束位置**才能产生过渡效果。

### 两种情况的差异

#### 情况A：注释掉 `item.visible = false`（有动画）

**执行流程：**

1. 用户切换列数
2. `fullReflow()` 被调用
3. 重置列高度，重建待排版队列
4. **项目保持 `visible: true` 状态**，仍然显示在**旧位置**
5. `processQueue()` 开始处理，计算新位置
6. 更新 `item.top` 和 `item.left` 为新位置
7. **CSS 检测到 `transform` 值变化**，触发过渡动画
8. 项目从旧位置平滑移动到新位置 ✅

#### 情况B：执行 `item.visible = false`（无动画）

**执行流程：**

1. 用户切换列数
2. `fullReflow()` 被调用
3. **立即设置所有项目 `visible: false`**
4. 项目变为不可见（`opacity: 0` 或完全隐藏）
5. 重置列高度，重建待排版队列
6. `processQueue()` 计算新位置并设置 `visible: true`
7. **项目直接在新位置显示**，没有位置变化过程
8. 只有透明度变化，没有位置动画 ❌

### 关键问题

问题在于 `waterfallItemClass` 的计算逻辑：

```typescript
const waterfallItemClass = computed(() => {
  return classNames(
    bem.b(),
    bem.m('show', item.visible || context.isReflowing), // 关键行
    bem.m('reflowing', context.isReflowing),
    itemId,
    props.rootClass,
  )
})
```

当 `item.visible = false` 时，如果 `context.isReflowing` 也是 `false`，那么 `show` 类就会被移除，导致项目完全隐藏，失去了动画的起始状态。

## 解决方案

### 方案1：优化重排状态管理（推荐）

```typescript
const processQueue = async () => {
  // 在开始处理队列时就设置重排状态，确保动画连续性
  if (pendingItems.length > 0) {
    isReflowing.value = true
  }

  updateLoadStatus()
  if (pendingItems.length === 0) return

  // 如果是完整重排，先隐藏所有待处理的项目
  if (pendingItems.length > 0) {
    pendingItems.forEach((item) => {
      item.visible = false // 现在可以安全隐藏，因为 isReflowing = true
    })
  }

  // ... 处理队列逻辑
}
```

### 方案2：延迟隐藏项目

```typescript
const fullReflow = debounce(async () => {
  if (!isActive.value) return

  // 设置重排状态
  isReflowing.value = true

  // 重置列
  initColumns()
  pendingItems.length = 0

  // 重置所有项目状态
  await resetItemsForReflow(items)

  // 延迟隐藏，让动画有时间开始
  await nextTick()

  // 现在可以安全隐藏
  items.forEach((item) => {
    item.visible = false
  })

  // 将所有项目加入待排版队列
  pendingItems.push(...items)

  // 开始处理队列
  processQueue()
}, 16)
```

### 方案3：改进样式逻辑

修改 `waterfallItemClass` 的计算逻辑：

```typescript
const waterfallItemClass = computed(() => {
  return classNames(
    bem.b(),
    // 重排时始终保持显示，确保动画连续性
    bem.m('show', item.visible || context.isReflowing),
    bem.m('reflowing', context.isReflowing),
    itemId,
    props.rootClass,
  )
})
```

并在 CSS 中优化：

```scss
.sar-waterfall-item {
  opacity: 0;

  &--show {
    opacity: 1;
  }

  &--reflowing {
    // 重排时保持可见，但可以有特殊样式
    opacity: 1;
  }
}
```

## 最终解决方案

采用**方案1**，在 `processQueue` 开始时就设置 `isReflowing.value = true`：

```typescript
const processQueue = async () => {
  // 在开始处理队列时就设置重排状态，确保动画连续性
  if (pendingItems.length > 0) {
    isReflowing.value = true
  }

  updateLoadStatus()
  if (pendingItems.length === 0) return
  // ... 其他逻辑
}
```

现在可以安全地启用隐藏逻辑：

```typescript
// 如果是完整重排，先隐藏所有待处理的项目
if (pendingItems.length > 0) {
  pendingItems.forEach((item) => {
    item.visible = false
  })
}
```

## 总结

这个问题的本质是**动画状态管理的时序问题**：

1. **有动画**：项目保持可见状态，位置变化时触发 `transform` 过渡
2. **无动画**：项目先隐藏再显示，失去了位置变化的过渡过程

通过在处理队列开始时就设置 `isReflowing = true`，确保即使 `item.visible = false`，项目仍然通过 `context.isReflowing` 保持可见状态，从而维持动画的连续性。
