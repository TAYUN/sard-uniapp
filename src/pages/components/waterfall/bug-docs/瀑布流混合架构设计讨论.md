# 瀑布流混合架构设计讨论

## 问题背景

用户希望整合两套瀑布流排版系统：

1. **processQueue (DOM测量模式)** - 用于初次排版，支持异步加载和实时DOM测量
2. **use-waterfall-reflow (纯算法模式)** - 用于后续操作，基于快照的纯数学计算

**目标**：初次排版使用DOM测量保证准确性，后续删除等操作使用纯算法提升性能。

## 两套系统对比分析

### processQueue (DOM测量模式)

**优势：**

- 实时DOM测量，高度准确
- 支持异步加载，等待图片等资源
- 渐进式渲染，用户体验好
- 处理复杂内容（文字换行、动态内容）

**劣势：**

- 性能开销大（DOM查询）
- 异步复杂度高
- 重排时需要重新测量

### use-waterfall-reflow (纯算法模式)

**优势：**

- 纯数学计算，性能极高
- 同步执行，逻辑简单
- 支持各种操作（增删改查）
- 可预测的结果

**劣势：**

- 依赖准确的初始快照
- 无法处理动态内容变化
- 需要预知所有项目尺寸

## 整合方案设计

### 方案1: 分阶段混合模式

```typescript
class HybridWaterfallManager {
  private mode: 'dom' | 'algorithm' = 'dom'
  private domManager: DOMLayoutManager
  private algorithmManager: WaterfallManager
  private snapshot: SnapshotItem[] = []

  // 初次排版：DOM模式
  async initialLayout(items: WaterfallItemInfo[]) {
    this.mode = 'dom'
    await this.domManager.processQueue(items)

    // 排版完成后生成快照
    this.generateSnapshot()
    this.mode = 'algorithm'
  }

  // 生成快照
  private generateSnapshot() {
    this.snapshot = this.domManager.items.map((item) => ({
      id: item.id,
      aspect: item.width / item.height, // 从DOM获取真实宽高比
      order: item.index,
    }))
    this.algorithmManager.initSnapshot(this.snapshot)
  }

  // 后续操作：算法模式
  removeItem(itemId: string | number) {
    if (this.mode === 'algorithm') {
      return this.algorithmManager.removeItem(itemId)
    }
    // 如果还在DOM模式，降级到DOM操作
    return this.domManager.removeItem(itemId)
  }
}
```

### 方案2: 智能切换模式

```typescript
class SmartWaterfallManager {
  private shouldUseAlgorithm(): boolean {
    return (
      this.isSnapshotReady &&
      !this.hasPendingLoads &&
      !this.hasLayoutParamsChanged
    )
  }

  async removeItem(itemId: string | number) {
    if (this.shouldUseAlgorithm()) {
      // 使用纯算法
      return this.algorithmManager.removeItem(itemId)
    } else {
      // 降级到DOM模式
      return this.domManager.removeItem(itemId)
    }
  }
}
```

## 关键挑战分析

### 1. 数据同步问题

```typescript
// 两套系统的数据结构不同
interface WaterfallItemInfo {
  // DOM模式
  loaded: boolean
  height: number // 实际DOM高度
  top: number
  left: number
}

interface SnapshotItem {
  // 算法模式
  aspect: number // 宽高比
  order: number
}
```

**解决方案：** 建立映射关系

```typescript
class DataBridge {
  private itemMap = new Map<
    string,
    {
      domItem: WaterfallItemInfo
      snapshotItem: SnapshotItem
    }
  >()

  syncFromDomToSnapshot(domItem: WaterfallItemInfo) {
    const snapshotItem = {
      id: domItem.id,
      aspect: domItem.width / domItem.height,
      order: domItem.index,
    }
    this.itemMap.set(domItem.id, { domItem, snapshotItem })
  }
}
```

### 2. 状态切换时机

```typescript
// 什么时候从DOM模式切换到算法模式？
const canSwitchToAlgorithm = () => {
  return (
    allItemsLoaded && // 所有项目加载完成
    !hasLayoutParamsChanged && // 布局参数未变化
    snapshotGenerated && // 快照已生成
    !hasPendingOperations // 无待处理操作
  )
}
```

### 3. 回退机制

```typescript
// 算法模式失败时如何回退？
class FallbackManager {
  async executeWithFallback<T>(
    algorithmFn: () => T,
    domFn: () => Promise<T>,
  ): Promise<T> {
    try {
      if (this.canUseAlgorithm()) {
        return algorithmFn()
      }
    } catch (error) {
      console.warn('算法模式失败，回退到DOM模式', error)
    }
    return await domFn()
  }
}
```

## 具体整合策略

### 阶段1: 初次排版（DOM模式）

```typescript
async initialRender() {
  // 1. 使用processQueue进行DOM测量排版
  await this.processQueue()

  // 2. 排版完成后生成快照
  this.generateSnapshot()

  // 3. 切换到算法模式
  this.switchToAlgorithmMode()
}
```

### 阶段2: 增删操作（算法模式）

```typescript
removeItem(itemId: string | number) {
  // 1. 检查是否可以使用算法模式
  if (this.canUseAlgorithm()) {
    // 2. 使用纯算法计算
    const result = this.algorithmManager.removeItem(itemId)

    // 3. 同步更新DOM项目状态
    this.syncAlgorithmResultToDom(result)

    return result
  }

  // 4. 降级到DOM模式
  return this.domRemoveItem(itemId)
}
```

### 阶段3: 参数变化（重新DOM模式）

```typescript
onLayoutParamsChange() {
  // 1. 切换回DOM模式
  this.switchToDomMode()

  // 2. 重新排版
  this.fullReflow()

  // 3. 重新生成快照
  this.generateSnapshot()

  // 4. 再次切换到算法模式
  this.switchToAlgorithmMode()
}
```

## 渐进式快照构建方案

基于第二个问题的讨论，提出了渐进式快照构建的改进方案：

### 渐进式快照管理器

```typescript
export interface ProgressiveSnapshotOptions {
  enableProgressive?: boolean // 是否启用渐进式模式
  minItemsForAlgorithm?: number // 切换到算法模式的最小项目数
  autoSwitchMode?: boolean // 是否自动切换模式
}

export function useWaterfallReflow(
  options: UseWaterfallReflowOptions & ProgressiveSnapshotOptions,
) {
  const {
    containerWidth,
    columns,
    columnGap = ref(10),
    rowGap = ref(10),
    immediate = true,
    enableProgressive = false,
    minItemsForAlgorithm = 10,
    autoSwitchMode = true,
  } = options

  const manager = new WaterfallManager()
  const layoutItems = ref<LayoutItem[]>([])
  const containerHeight = ref(0)
  const isInitialized = ref(false)

  // 新增：渐进式状态管理
  const mode = ref<'progressive' | 'algorithm'>('progressive')
  const snapshotItems = ref<WaterfallItem[]>([]) // 已添加到快照的项目
  const pendingDomItems = ref<WaterfallItem[]>([]) // 等待DOM排版的项目

  /**
   * 渐进式添加快照项目
   */
  const addSnapshotItem = (item: WaterfallItem) => {
    if (!enableProgressive) return

    // 添加到快照列表
    snapshotItems.value.push(item)

    // 如果是第一个项目，初始化管理器
    if (snapshotItems.value.length === 1) {
      manager.initSnapshot([item])
      isInitialized.value = true
    } else {
      // 追加到现有快照
      manager.appendItem(item)
    }

    // 检查是否可以切换到算法模式
    if (autoSwitchMode && snapshotItems.value.length >= minItemsForAlgorithm) {
      switchToAlgorithmMode()
    }

    // 更新布局
    executeReflow()
  }

  /**
   * 切换到算法模式
   */
  const switchToAlgorithmMode = () => {
    if (mode.value === 'algorithm') return

    mode.value = 'algorithm'
    console.log(`切换到算法模式，当前快照项目数: ${snapshotItems.value.length}`)
  }

  return {
    // 原有接口保持不变
    layoutItems: readonly(layoutItems),
    containerHeight: readonly(containerHeight),
    isInitialized: readonly(isInitialized),

    // 新增：渐进式接口
    mode: readonly(mode),
    snapshotItems: readonly(snapshotItems),
    addSnapshotItem,
    switchToAlgorithmMode,

    // 原有方法
    initSnapshot,
    initialize,
    reflow,
    insertItem,
    appendItem,
    removeItem,
    replaceItem,
    batchUpdate,
    getSnapshot,
    getParams,
  }
}
```

### 与 processQueue 集成

```typescript
const processQueue = async () => {
  // ... 原有逻辑

  while (pendingItems.length > 0) {
    const item = pendingItems[0]

    // 等待加载完成
    if (!item.loaded) {
      await new Promise<void>((resolve) => {
        const unwatch = watch(
          () => item.loaded,
          (newLoaded) => {
            if (newLoaded) {
              unwatch()
              resolve()
            }
          },
          { immediate: true },
        )
      })
    }

    // DOM 排版逻辑
    const currentMinColumn = getMinColumn()
    item.top = currentMinColumn.height + props.rowGap
    item.left =
      (props.columnGap + columnWidth.value) * currentMinColumn.colIndex

    const targetColumnIndex = currentMinColumn.colIndex
    const newHeight = item.top + item.height
    columns[targetColumnIndex].height = newHeight

    item.visible = true

    // 🔥 关键：添加到渐进式快照
    addSnapshotItem({
      id: item.id || item.index,
      width: columnWidth.value, // 使用计算出的列宽
      height: item.height, // 使用DOM测量的高度
      // 可以添加更多元数据
      domTop: item.top,
      domLeft: item.left,
      columnIndex: targetColumnIndex,
    })

    pendingItems.shift()
  }

  // 处理完成后的逻辑
  containerHeight.value = Math.max(...columns.map((col) => col.height), 0)

  // 检查是否可以完全切换到算法模式
  if (pendingItems.length === 0 && items.length >= 10) {
    switchToAlgorithmMode()
  }
}
```

### 智能模式切换

```typescript
/**
 * 智能决策：使用哪种模式处理操作
 */
const shouldUseAlgorithm = (operation: string) => {
  const conditions = {
    hasEnoughSnapshot: snapshotItems.value.length >= minItemsForAlgorithm,
    noLayoutParamsChange: !layoutParamsChanged.value,
    noPendingLoads: pendingDomItems.value.length === 0,
    supportedOperation: ['remove', 'insert', 'replace'].includes(operation),
  }

  return Object.values(conditions).every(Boolean)
}

/**
 * 混合模式删除项目
 */
const hybridRemoveItem = (itemId: string | number) => {
  if (shouldUseAlgorithm('remove')) {
    // 使用算法模式
    console.log('使用算法模式删除项目')
    const result = manager.removeItem(itemId)
    layoutItems.value = result.items
    containerHeight.value = result.containerHeight

    // 同步更新快照列表
    const index = snapshotItems.value.findIndex((item) => item.id === itemId)
    if (index !== -1) {
      snapshotItems.value.splice(index, 1)
    }

    return result
  } else {
    // 降级到DOM模式
    console.log('降级到DOM模式删除项目')
    throw new Error('需要使用DOM模式处理，请调用原始删除方法')
  }
}
```

## 关键技术点

### 1. 快照数据转换

```typescript
// DOM项目 → 快照项目
const domItemToSnapshot = (
  domItem: WaterfallItemInfo,
  columnWidth: number,
): WaterfallItem => {
  return {
    id: domItem.id || domItem.index,
    width: columnWidth, // 统一使用列宽
    height: domItem.height, // 使用DOM测量的真实高度
    // 保存DOM排版结果作为验证
    _domResult: {
      top: domItem.top,
      left: domItem.left,
      columnIndex: Math.round(domItem.left / (columnWidth + columnGap)),
    },
  }
}
```

### 2. 模式切换时机

```typescript
const checkModeSwitch = () => {
  const canSwitch =
    snapshotItems.value.length >= minItemsForAlgorithm && // 有足够的快照
    pendingItems.length === 0 && // 没有待处理项目
    !layoutParamsChanged.value && // 布局参数未变化
    allItemsLoaded.value // 所有项目已加载

  if (canSwitch && mode.value === 'progressive') {
    switchToAlgorithmMode()
  }
}
```

### 3. 数据一致性验证

```typescript
const validateConsistency = () => {
  // 比较DOM排版结果和算法计算结果
  const domResult = getDomLayoutResult()
  const algorithmResult = manager.updateParams(params.value)

  const isConsistent = domResult.items.every((domItem, index) => {
    const algItem = algorithmResult.items[index]
    return (
      Math.abs(domItem.top - algItem.top) < 1 &&
      Math.abs(domItem.left - algItem.left) < 1
    )
  })

  if (!isConsistent) {
    console.warn('DOM和算法结果不一致，建议重新生成快照')
  }

  return isConsistent
}
```

## 可行性评估

### ✅ 可行的部分

1. **技术上完全可行** - 两套系统可以共存
2. **性能提升明显** - 删除操作从异步DOM变为同步计算
3. **用户体验好** - 初次加载准确，后续操作流畅

### ⚠️ 需要注意的挑战

1. **复杂度增加** - 需要维护两套系统和同步逻辑
2. **内存开销** - 需要同时保存DOM状态和快照数据
3. **边界情况** - 需要处理各种异常和回退场景
4. **调试难度** - 两套系统的问题定位更复杂

### 🎯 建议的实现优先级

1. **先实现基础整合** - 简单的DOM→算法切换
2. **完善同步机制** - 确保数据一致性
3. **添加回退逻辑** - 处理异常情况
4. **性能优化** - 减少不必要的计算和存储

## 总结

这个混合架构设计**技术上完全可行**，而且是一个很有创新性的方案。关键是要：

1. **明确切换时机** - 什么时候用DOM，什么时候用算法
2. **保证数据同步** - 两套系统的状态要一致
3. **处理边界情况** - 异常时的回退机制
4. **渐进式实现** - 先做基础功能，再完善细节

这种混合模式可以充分发挥两种方案的优势：

- **DOM模式**：保证初次排版的准确性和对复杂内容的支持
- **算法模式**：提供后续操作的高性能和流畅体验
- **渐进式快照**：实现无缝的模式切换和性能优化

是一个很值得尝试的架构设计！
