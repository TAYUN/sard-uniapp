# 瀑布流状态管理设计对比

## 问题背景

在实现瀑布流重排动画时，需要管理 `isReflowing` 状态来控制项目在重排过程中的显示效果。这个状态可以在两个地方管理：

1. **每个项目自己管理**（原始设计）
2. **父组件统一管理**（优化设计）

## 方案对比

### 方案一：每个项目自己管理

```typescript
// WaterfallItemInfo 接口
export interface WaterfallItemInfo {
  // ... 其他属性
  isReflowing?: boolean // 每个项目自己的重排状态
}

// 在 waterfall.vue 中
const getItemHeight = (items, smoothTransition) => {
  items.forEach((item) => {
    item.isReflowing = smoothTransition // 每个项目单独设置
  })
}

// 在 waterfall-item.vue 中
const waterfallItemClass = computed(() => {
  return classNames(
    bem.m('reflowing', item.isReflowing), // 使用自己的状态
  )
})
```

**优点：**

- ✅ 数据就近原则，状态和使用者在一起
- ✅ 实现简单，不需要复杂的状态传递
- ✅ 理论上支持项目级别的独立重排状态

**缺点：**

- ❌ 状态分散，父组件难以统一控制
- ❌ 可能出现状态不一致的情况
- ❌ 每个项目都要处理相同的重排逻辑
- ❌ 内存占用稍高（每个项目都存储状态）
- ❌ 状态清理复杂，需要逐个处理

### 方案二：父组件统一管理（推荐）

```typescript
// WaterfallContext 接口
export interface WaterfallContext {
  // ... 其他属性
  isReflowing: boolean // 全局重排状态
}

// 在 waterfall.vue 中
const isReflowing = ref(false)

const smoothReflow = () => {
  isReflowing.value = true // 统一设置全局状态
  // ... 重排逻辑
}

// 在 waterfall-item.vue 中
const waterfallItemClass = computed(() => {
  return classNames(
    bem.m('reflowing', context.isReflowing), // 使用全局状态
  )
})
```

**优点：**

- ✅ 状态集中管理，逻辑清晰
- ✅ 保证所有项目状态一致
- ✅ 父组件可以统一控制重排流程
- ✅ 内存占用更少（只有一个全局状态）
- ✅ 状态清理简单，一次性处理
- ✅ 更符合 React/Vue 的状态管理最佳实践

**缺点：**

- ❌ 需要通过上下文传递状态
- ❌ 不支持项目级别的独立重排（实际上也不需要）

## 实际应用分析

### 业务需求分析

在瀑布流场景中：

- **重排是全局行为**：当列数变化时，所有项目都需要重新排列
- **状态应该一致**：所有项目应该同时进入/退出重排状态
- **不需要独立控制**：没有业务场景需要部分项目重排，部分不重排

### 性能考虑

**方案一（分散管理）：**

- 每个项目存储 `isReflowing` 状态：假设100个项目 = 100个布尔值
- 状态更新时需要遍历所有项目逐个设置
- 状态清理时需要逐个检查和清理

**方案二（集中管理）：**

- 只有一个全局 `isReflowing` 状态：1个布尔值
- 状态更新一次性完成
- 状态清理一次性完成

### 代码维护性

**方案一：**

```typescript
// 设置重排状态 - 需要遍历所有项目
items.forEach((item) => (item.isReflowing = true))

// 清理重排状态 - 需要在每个项目完成时检查
setTimeout(() => {
  item.isReflowing = false
  // 需要检查是否所有项目都完成了
}, delay)
```

**方案二：**

```typescript
// 设置重排状态 - 一次性完成
isReflowing.value = true

// 清理重排状态 - 在合适的时机一次性清理
if (pendingItems.length === 0) {
  isReflowing.value = false
}
```

## 结论

**推荐使用方案二（父组件统一管理）**，原因如下：

1. **符合业务逻辑**：重排是全局行为，应该有全局状态
2. **性能更优**：减少内存占用和状态更新开销
3. **代码更清晰**：状态管理逻辑集中，易于理解和维护
4. **一致性保证**：避免状态不一致的问题
5. **扩展性更好**：未来如果需要添加其他全局状态，架构已经就绪

## 重构后的架构

```
瀑布流组件 (waterfall.vue)
├── 全局状态管理
│   ├── isReflowing: boolean
│   ├── containerHeight: number
│   └── columns: Array
├── 重排逻辑
│   ├── smoothReflow()
│   ├── fullReflow()
│   └── processQueue()
└── 上下文提供
    ├── columnWidth
    ├── isReflowing ← 通过上下文传递
    └── 各种方法

瀑布流项目 (waterfall-item.vue)
├── 项目状态管理
│   ├── visible: boolean
│   ├── height: number
│   └── position: {top, left}
├── 样式计算
│   └── 使用 context.isReflowing ← 从上下文获取
└── 动画效果
```

这种架构更符合组件设计的单一职责原则和状态管理的最佳实践。
